---
title: GBDT模型
date: 2018-07-27 07:19:11
tags: 
- 机器学习
- 集成学习
categories: 
- 机器学习
- 集成学习
---

[集成学习方法](https://yuancl.github.io/2018/07/24/ml/集成学习方法/)

#### GB(Gradient Boosting)理解
- 理解梯度下降
  - 求解目标函数$J(\theta)$的最优解，本质上是一轮一轮的求解w
  - 对于最终的最后解W*,是由初始值$w_0$经过M次迭代得到的
  
- 对比理解多轮迭代后的GB函数最优解
  - $f(x)$经过M次迭代，得到$F(x)=\sum_{i=1}^m\theta _if_i(x)$
  - 这里是反向思考：因为梯度下降是通过梯度下降的方法求出w参数值，最后就是经过了M轮迭代求出最优解w*.  这里的w是参数，同样的思想对比到函数F(x)上,<font color='blue'>将F(x)视为整体类似于w</font>，最后通过多轮迭代求出F*(x)最优解
  - 梯度增强的作者们意识到，如果使用“梯度下降”（Gradient Descent）来优化一个目标函数，最后的预测式可以写成一个加和的形式。也就是，每一轮梯度的值和一个叫“学习速率”（Learning Rate）的参数共同叠加起来形成了最后的预测结果。这个观察非常重要，如果把这个观察和我们的目标，也就是构造弱学习器的加权平均联系起来看，我们就会发现，<font color='blue'>其实每个梯度的值就可以认为是一个弱学习器，而学习速率就可以看作是某种意义上的权重</font>
  - 每一轮迭代，我们把当前所有学习器的加权平均结果当作这一轮的函数值，然后求得针对某一个损失函数对于当前所有学习器的参数的一个梯度。<strong>然后，我们利用某一个弱学习器算法，可以是线性回归模型（Linear Regression）、对数几率模型（Logistic Regression）等来拟合这个梯度</strong>。<strong>最后，我们利用“线查找”（Line Search）的方式找到权重</strong>。
    - 说得更直白一些，<font color='red'>那就是我们尝试利用一些简单的模型来拟合不同迭代轮数的梯度</font>
    - 梯度增强的一个特点就是梯度下降本身带来的，那就是每一轮迭代一定是去拟合比上一轮小的一个梯度，函数对目标的整体拟合也是越来越好的。这其实也就是增强算法和梯度下降的一个完美结合
- 可以看出上述是一个求解梯度的过程，因此也称为基于梯度的Boost方法(即GB:Gradient Boosting)

- 算法
  - 这里的m是m个机器学习模型，n应该是样本的数量。这里就能够看出，boost方法就是前一轮的结果会影响后一轮
  {% asset_img resources/297ED5E7B40AD7E5192DB0EE79E577F7.jpg %}
  - 一般定义不同的Loss函数，就能得到不同的算法，比如这里用二分类任务中常用的$L(y,F)=log(1+exp(-2yF)), y \in {(-1,1)}$,就能得到如下算法：
  {% asset_img resources/DB082CA541217CF13A4A4DC535C9D2F0.jpg %}

#### DT理解
参考[决策树](https://yuancl.github.io/2018/08/06/ml/决策树/)